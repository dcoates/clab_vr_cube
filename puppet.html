<!DOCTYPE html>
<html lang="en">
<head>
	<title>CLAB VR Disparity Objects (puppet)</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	<link type="text/css" rel="stylesheet" href="main.css">
</head>
<body>

<div id="info">CLAB VR Disparity Objects (puppet)</div>

<script src="loglevel.min.js"></script>
<script src="https://unpkg.com/peerjs@1.3.1/dist/peerjs.min.js"></script>
<script src="mypeer.js" type="text/javascript"> </script>
<script src="helpers.js" type="text/javascript"> </script>

<script type="module">

import * as THREE from '../three.js/build/three.module.js';

import { BoxLineGeometry } from '../three.js/examples/jsm/geometries/BoxLineGeometry.js';
import { VRButton } from '../three.js/examples/jsm/webxr/VRButton.js';
import { ShaderPass } from '../three.js/examples/jsm/postprocessing/ShaderPass.js';
import { LumGammaShader } from './lum_gamma_shader.js';

// Global variables: only list variables here, no code 
var clock = new THREE.Clock();
var thePeer;    // For our PC communication
var driver_id;  // load_code will init

var trial_num=0; // Count up which trial we are on

// This function is called each time a key is hit
function handle_key(e) {
	// TODO: send key back to driver
};

// For three.js:
var container;
var camera, scene, renderer;
var room;

// Our new post-processing shader:
var luminosityPass = null; // must be global so we can change parameters
var baseLayer = null; 
var renderTarget = null;
var XRready= false;
var cameraVR = null;

// For PC communication:
var handler_uploader={
id: function(s) {
	    setTimeout( function() {thePeer.join(driver_id);},    500 );
    },
lost: function(s) {log.info(s);},
      error: function(s) {log.info(s);},
      connect: function(s) {log.info('paired '+s);},
      peer_info: function(s) {log.info(s);},
      unpair: function (s) {log.info('unpaired',s);},
      keyboard: function (nkey) {do_kb(nkey);},
      receive: receive_commands,
};

//New textured room
var texturedroomgeometry = new THREE.BoxGeometry (10,10,10);
var sf1 = THREE.ImageUtils.loadTexture( './sf_texture1.00.png' );
var sf4 = THREE.ImageUtils.loadTexture( './sf_texture4.00.png' );
var sf8 = THREE.ImageUtils.loadTexture( './sf_texture8.00.png' );
var texturedsf1 = new THREE.MeshLambertMaterial( { map: sf1, side: THREE.BackSide } );
//var texturedsf4 = new THREE.MeshLambertMaterial( { map: sf4, side: THREE.BackSide } );
//var texturedsf8 = new THREE.MeshLambertMaterial( { map: sf8, side: THREE.BackSide } );
var texturedroom;

/*
To update the texture, something like this:

new THREE.TextureLoader().load(
  "https://images.pexels.com/photos/1089438/pexels-photo-1089438.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260",
  texture => {
    //Update Texture
    this.earthMesh.material.map = texture;
    this.earthMesh.material.needsUpdate = true;
  },
*/

function receive_commands(s) {
	console.log(s);
	if (s[0]=="C") { // js commands to execute
		eval(s.substr(2));
	}
}

function setGlobals(params) {
    Object.keys(params).map(function(key,index) {
        luminosityPass.uniforms[key].value=params[key];
    });
}

function setupShader(wid) {
	if ( wid === undefined ) {
        wid=100; //testing/debugging
        }
	luminosityPass = new ShaderPass( LumGammaShader );

	// Set the luminance (0-1.0) here:
	// Gamma defaults to 2.4 (for Samsung S6)
    var defaults={'intensity1':1.0, 'intensity2':1.0,
            'con1':1.0, 'con2':1.0, 'canvas_half':wid};
    setGlobals(defaults);
}

function setupXRshader() {
    console.log('Trying setupXR');
    baseLayer=document.rend.xr.getSession().renderState.baseLayer;
    renderTarget = new THREE.WebGLRenderTarget( baseLayer.framebufferWidth, baseLayer.framebufferHeight );
    renderTarget.texture.name = 'XRtemp.rt1';
    setupShader(baseLayer.framebufferWidth/2.0);
    XRready=true;
	console.log(baseLayer.framebufferWidth, baseLayer.framebufferHeight); 
}
function obf(renderer, scene, camera, local_renderTarget) {
}

// This is called once to initialize:
var dict_params = {}; // GLOBAL
init();
function init() {
	// Read "command line" parameters
	location.search.substr(1).split("&").forEach(function(item) {dict_params[item.split("=")[0]] = item.split("=")[1]})

    if ('driver_id' in dict_params) {
        driver_id=dict_params['driver_id'];
    } else { 
        driver_id='a10001';
    }

	// Set up our key handler
	//document.onkeydown = handle_key;

	// Set up communication with the PC
	thePeer=new MyPeer(handler_uploader);
	thePeer.init();

	// Set up Three.js scene: from box example.
	container = document.createElement( 'div' );
	document.body.appendChild( container );

	scene = new THREE.Scene();
	scene.background = new THREE.Color( 0x808080 ); //0x000000, 0x202020, 0x404040, 0x606060, 0x808080, 0xA0A0A0, 0xC0C0C0, 0xE0E0E0, 0xFFFFFF

	camera = new THREE.PerspectiveCamera( 120, window.innerWidth / window.innerHeight, 0.1, 100 );

	camera.position.set( 0, 0, 0);
	//camera.rotation.set(0, Math.PI/2.0, 0); //set in radian 90 degree
	camera.updateProjectionMatrix();
	scene.add( camera );

	room = new THREE.LineSegments(
			new BoxLineGeometry( 10,10,10, 1,1,1).translate( 0, 0, 0 ), // first size, second density?
			new THREE.LineBasicMaterial( { color: 0x000000 } )
			);
	scene.add( room );
	
	texturedroom= new THREE.Mesh(texturedroomgeometry, texturedsf1);
	scene.add( texturedroom );

	//scene.add( new THREE.HemisphereLight( ) );

	var light = new THREE.AmbientLight( 0xffffff,1);
	light.position.set( 0, 0, 0 ).normalize();
	scene.add( light );

	var geometry = new THREE.BoxBufferGeometry( 0.2, 0.2, 0.2); // use this same geom for all objects

	// 3 Cubes
	for ( var i = 0; i < 3; i ++ ) {
		// RGB: 0x808080, half red , "HTML color"
		//var textureSf = THREE.ImageUtils.loadTexture( './sf_texture1.00.png' );
		//textureSf.wrapS = THREE.RepeatWrapping;
		//textureSf.wrapT = THREE.RepeatWrapping;
		//textureSf.repeat.set( 0.25,0.25 );
		var materialSf = new THREE.MeshLambertMaterial( { map: sf8 } );
		var object = new THREE.Mesh( geometry, materialSf, (1,1,1)); //new THREE.MeshLambertMaterial( { color: 0x808080 } )

		object.position.x = (i/3.0-1/3); //Math.random() * 1 - 0.5;
		object.position.y = 1.6; //Math.random() * 1;
		object.position.z = 0; //Math.random() * 1 - 0.5;

		object.scale.x = 1.0; 
		object.scale.y = 1.0; 
		object.scale.z = 0.001;

		room.add( object );
	}

	renderer = new THREE.WebGLRenderer( { antialias: true } );
	renderer.setPixelRatio( window.devicePixelRatio );
	renderer.setSize( window.innerWidth, window.innerHeight );
	renderer.outputEncoding = THREE.sRGBEncoding;
	renderer.xr.enabled = true;
	renderer.gammaFactor = 1;
	container.appendChild( renderer.domElement );
    document.rend=renderer;
    //scene.onBeforeRender=obf; // this will eventually be useful (to get cameras)
	document.body.appendChild( VRButton.createButton( renderer ) );
	renderer.setAnimationLoop( render, camera);
}

function erasecubes(){
	room.children[0].position.y=100; //Move the cubes far away/out of sight
	room.children[1].position.y=100;
	room.children[2].position.y=100;
}

function render() {

    if (XRready) {

        renderer.setRenderTarget( renderTarget );
		renderer.setViewport( 0, 0, baseLayer.framebufferWidth, baseLayer.framebufferHeight );
		renderer.setScissor ( 0, 0, baseLayer.framebufferWidth, baseLayer.framebufferHeight );
        renderer.xr.enabled=true; // to prevent it from overriding camera
	    renderer.render( scene, camera );

        // Set the copy target to the actual real layer than WebXR uses
        renderer.setFramebuffer( baseLayer.framebuffer );
		renderer.setViewport( 0, 0, baseLayer.framebufferWidth, baseLayer.framebufferHeight );
		renderer.setScissor ( 0, 0, baseLayer.framebufferWidth, baseLayer.framebufferHeight );
	    renderer.setDrawingBufferSize ( baseLayer.framebufferWidth, baseLayer.framebufferHeight, 1.0 );

        luminosityPass.renderToScreen=true; // Don't use a renderTarget; use the FB we set above
        renderer.xr.enabled=false; // to prevent it from overriding camera
        luminosityPass.render( renderer, null, renderTarget ); 
    } else {
        if  (false) { // This does non-VR with our post-proc shader (need to send renderTarget first though)
            luminosityPass.renderToScreen=false; // Render to texture
            renderer.setRenderTarget( renderTarget );
	        renderer.render( scene, camera );

            luminosityPass.renderToScreen=true; // Don't use a renderTarget; use the FB we set above
            luminosityPass.render( renderer, null, renderTarget );
        } else { // non-VR, no post-proc shader:
	        renderer.render( scene, camera );
        }
    }
}


</script>
</body>
</html>
